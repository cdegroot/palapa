# Uderzo

Uderzo is an idea at the moment, nothing more. Maybe some code will follow. Needless to
say, named after the Asterix creator, the half from the genius duo that made the images
(if I ever write a Elixir-based wordprocessor, it'll be called Goscinny. Promise).

The idea is to have an Elixir GUI in the following way:

* An executable that listens on an Erlang port and includes [NanoVG](https://github.com/memononen/nanovg)
* A library in Elixir that roughly replicates [NanoGUI](https://github.com/wjakob/nanogui)

The reason to separate the vector graphics and the GUI are multiple:
* With the OpenGL stuff in a separate executable, it can crash without taking down BEAM. Restart strategies are possible;
* The interesting bits are kept in Elixir and thus will be modifiable, etcetera. There's a ton of fun stuff you can do when your widget library is truly native and you have a code environment that's dynamic. See Morphic, Lively Kernel, etcetera.
* I'd like to abuse the opportunity to see whether the widgets can be generated by a DSL, pulling all the stops on macros and maybe some more advanced parsing as well.

Steps:

* [x] Build a basic wrapper executable
* [x] Open a window, show the NanoVG Demo
* [ ] Receive a mouseclick
* [ ] Lots and lots and lots of hard work to tie everything together.

# Setup

* Have a bunch of stuff installed. On Debian, you can do `make -f Makefile.linux setup`,
  on other platforms YMMV, check the Makefile for details of what you need.
* `mix deps.get`
* `mix compile`
* `mix test` should now briefly open a window with the first frame. If that works,
  you can go to the next level:
* `iex -S mix` and run `Uderzo.Demo.run` from there.

Note: I'm doing nothing yet to make this work on non-linux envs, but also nothing to
make that hard. Nanovg is portable, and the wrapper executable should be minimal.

# Protocol

To get started, we KISS and just use erlang term format. Later on we can have some hand-optimized
RPC going on.

Messages are fully async, so if you want a response, you need to send a pid to receive the
response along. By convention, we send that pid as the last argument on a call and
return responses as `{pid, response}` - the graphics genserver then simply dispatches
that with `send(pid, response)` and we're in Elixir-land from there.

We use the direct names of the GLFW/OpenGL/NanoVG libraries, uncamelcased. Pointers to
hold return values are converted to return tuples. E.g.

```c
  double mx, my;
  GLFWwindow *window;

  glfwGetCursorPos(window, &mx, &my);
```

becomes

```elixir
  glfw_get_cursor_pos(window, self())
  receive do
    {mx, my} -> ....
  end
```

There is ample room for crashing the graphics server - pointers to windows, etcetera, are
directly returned as 64 bit numbers. As long as you just store and send them back as
opaque handles, everything is fine. If you don't, you will have spectacular crashes.

Note that crashing the graphics server should be fine: processes can monitor the
GenServer that will crash along, re-open the window, and simply resume the rendering
loop. With a bit of luck, it should be just a flicker.

TBD: Keyboard, mouse callbacks. These will be sent to pre-registered processes that
want them.

# Clixir

_Disclaimer: this is design documentation, actual implementation may have differences. See
the code, `lib/uderzo/clixir.ex` and the associated test for actuals_

We write the C code in Elixir and use macros to generate both the Elixir bindings
and the C code. This idea was blatantly stolen from Squeak Smalltalk. As we aim
for a very low level interface, all the functions will have the same structure in
C: unmarshall arguments, make call, marshall return values; so "Clixir" can start
out simple.

```elixir

  defgfx glfw_get_cursor_pos(window, pid) do
    cdecl "GLFWwindow *": window
    cdecl erlang_pid: pid
    cdecl double: [mx, my]
    glfwGetCursorPos(window, &mx, &my)
    {pid, {mx, my}}
  end
```

will result in this Elixir code (both a regular and a blocking synchronous version
are generated, although I think the sync version shouldn't be used ;-)):

```elixir
  @spec glfw_get_cursor_pos(integer, pid) :: none
  def glfw_get_cursor_pos(window, pid) do
    GraphicsServer.send_command(GraphicsServer, {:glfw_get_cursor_pos, window, pid})
  end

  @spec glfw_get_cursor_pos_s(integer) :: {float, float}
  def glfw_get_cursor_pos(window) do
    glfw_get_cursor_pos(window, self)
    receive do
      {mx, my} when is_float(mx) and is_float(my) -> {mx, my}
    end
  end
```

and the following C code:

```c
static void _dispatch_glfw_get_cursor_pos(const char *buf, unsigned short len, int *index) {

  GLFWwindow *window;
  erlang_pid pid;
  double mx, my;

  assert(ei_decode_longlong(buf, index, (long long *) &window) == 0);
  assert(ei_decode_pid(buf, index, &pid) == 0);

  glfwGetCursorPos(window, &mx, My);

  ei_encode_version(response, &response_index);
  ei_encode_tuple_header(response, &response_index, 2);
  ei_encode_pid(response, &response_index, &pid);
  ei_encode_tuple_header(response, &response_index, 2);
  ei_encode_double(response, &response_index, mx);
  ei_encode_double(response, &response_index, my);

  write_response_bytes(response, response_index);
}
```

The idea is to write a Clixir wrapper for every NanoVG/GLFW/OpenGL function under the sun.

Readme-driven development means that most of this is a lie. To do:

* [x] Basic C code generation
* [x] Basic Elixir code generation
* [x] Emit C code in a separate source file in c_src
* [x] Generate a jump table using GNU gperf
* [x] Tie all C bits together
* [x] Have a method for "special" functions (see e.g. makewindow)?
* [ ] Implement all NanoVG methods
* [ ] Keyboard, mouse callbacks and code generation for that?
* [ ] Inter-process comms, have processes subscribe to GraphicsServer so they can
      act on crashes
* [ ] Demo time ;-)
* [ ] (optional) Emit sync methods?
