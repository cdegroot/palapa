/*
 *  Clixir Support and I/O functions.
 *
 *  The stuff that talks to BEAM lives here.
 */
#include "clixir_support.h"

static void handle_command(const char *command, unsigned short len);

void clixir_read_loop() {
    // Protocol: 2 bytes with big endian length, then the actual command.
    // So maximum size we can read is 65535. We're not even gonna allocate
    // that with today's stack sizes and a single process. Once we start pushing
    // large graphics objects like bitmaps through the pipe, we'll regret the
    // decision but maybe by then we have converted this to a full C node.
    char buffer[BUF_SIZE];
    unsigned char size_buffer[2];

    while (1) { // TODO how do we end the fun?
        assert(read(STDIN_FILENO, size_buffer, 2) == 2);
        unsigned short size = (size_buffer[0] << 8) + size_buffer[1];

        unsigned short bytes_read = read(STDIN_FILENO, buffer, size);
        if (bytes_read < 0) {
            fprintf(stderr, "Error, read %d bytes, expected positive number\n", bytes_read);
            exit(-1);
        } else if (bytes_read < size) {
            fprintf(stderr, "Error, short read. Expected %d, got %d\n", size, bytes_read);
            dump_hex(buffer, bytes_read);
            exit(-1);
        } else {
            dump_hex(buffer, size);
            handle_command(buffer, size);
        }
    }
}

// _dispatch_command will be generated by Clixir, this is its signature:
extern void _dispatch_command(const char *buf, unsigned short len, int *index);

static void _handle_command(const char *command, unsigned short len, int *index) {
    // For now, we parse the command, then echo it back.
    // Note that all we accept for now is
    //   {cast, <<function_name>>, args.... [, callback_pid]}
    // Or, preferably, an array of these.
    ei_term term;

    if (*index >= len) {
        return;
    }

    int result = ei_decode_ei_term(command, index, &term);
    assert(result == 1);
    switch (term.ei_type) {
    case ERL_SMALL_TUPLE_EXT:
        _dispatch_command(command, len, index);
        _handle_command(command, len, index);
        break;
    case ERL_LIST_EXT:
        // A list of commands; we can send this for efficiency. Loop and go.
        for (int i = 0; i < term.arity; i++) {
            _handle_command(command, len, index);
        }
        break;
    case ERL_NIL_EXT:
        // Skip nil.
        break;
    default:
        fprintf(stderr, "Unknown term type %c / %d\n", term.ei_type, term.ei_type);
        assert(1 == 0);
    }
}
static void handle_command(const char *command, unsigned short len) {
  int index = 1;
  _handle_command(command, len, &index); // Skip version number
}


void write_single_atom(const char *atom) {
    char buffer[MAXATOMLEN];
    int index = 0;

    ei_encode_version(buffer, &index);
    ei_encode_atom(buffer, &index, atom);

    write_response_bytes(buffer, index);
}

// Not entirely correctly named, but usually what we want - an {atom, binary} 2-tuple
void write_response_tuple2(const char *atom, const char *message) {
    char buffer[BUF_SIZE];
    int index = 0;

    ei_encode_version(buffer, &index);
    ei_encode_tuple_header(buffer, &index, 2);
    ei_encode_atom(buffer, &index, atom);
    ei_encode_binary(buffer, &index, message, strlen(message));

    write_response_bytes(buffer, index);
}

void write_response_bytes(const char *bytes, unsigned short len) {
    struct iovec iov[2];
    unsigned char size_buffer[2];

    size_buffer[0] = len >> 8;
    size_buffer[1] = len & 0xff;

    iov[0].iov_base = size_buffer;
    iov[0].iov_len  = 2;
    iov[1].iov_base = (char *) bytes; // ok to drop the const here, read-only access
    iov[1].iov_len  = len;

    dump_hex(size_buffer, 2);
    dump_hex(bytes, len);
    assert (writev(STDOUT_FILENO, iov, 2) == len + 2);
}

// For debugging, shamely stolen from github
// https://gist.githubusercontent.com/ccbrown/9722406/raw/05202cd8f86159ff09edc879b70b5ac6be5d25d0/DumpHex.c

void dump_hex(const void* data, size_t size) {
#ifdef CLIXIR_PROTOCOL_DUMP
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        fprintf(stderr,"%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            fprintf(stderr," ");
            if ((i+1) % 16 == 0) {
                fprintf(stderr,"|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    fprintf(stderr," ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    fprintf(stderr,"   ");
                }
                fprintf(stderr,"|  %s \n", ascii);
            }
        }
    }
    fflush(stderr);
#endif
}
